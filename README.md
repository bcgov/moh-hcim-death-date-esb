# HCIM DeathDate ESBApp

[![Lifecycle:Maturing](https://img.shields.io/badge/Lifecycle-Maturing-007EC6)](https://github.com/bcgov/repomountie/blob/master/doc/lifecycle-badges.md)

Welcome to the code repository for the HCIM DeathDate ESB App.

## Running the App in Docker on a Local Machine

Prerequisites:
- You have an ActiveMQ JMS broker running and listening for tcp requests on port 61616
  - If you don't, see [Setting Up an ActiveMQ Broker](#Setting Up an ActiveMQ Broker).

To run the app in docker on a local machine, build the Docker image from the provided Dockerfile.

```
docker build -t {name-of-image} {path-to-Dockerfile-directory}
```

Then run the Docker container and map it to port 8080. Make sure you have the correct environment variables in your .env file and that all of the passwords are correct.

```
docker run --name {name-of-container} --env-file {path-to-env-file} -p 8080:8080 {name-of-image}
```

### Verifiying that the app is running

To make sure the app is running, visit `http://localhost:8080/DeathDate`. You should see a simple web page showing the header "CRS Death Date".

The app is also configured to check the ftp server for files at times determined by the SCHEDULER_CRON environment variable (note that this cron syntax includes a "seconds" field in the leftmost position in addition to all of the regular fields). Check the logs for output at the appropriate times and ensure that there are no errors. The program should grab the file, log some information in the database, and delete the file.

### Database setup

To set up the application's database, run `deathdate_pg.sql` in a new database named `registries`. The script will create a user called "role_esb_death" with superuser priviliges (change these privileges later) and all of the tables and sequences required by the application. Then you need to add a password for the user; you can do this either with the `\password role_esb_death` command in a psql terminal, or you can modify the `create user role_esb_death superuser` line in `deathdate_pg.sql` to end with `password {password}`.

## Setting Up an ActiveMQ Broker

The app uses an ActiveMQ JMS broker. To set one up, first download [ActiveMQ 5](https://activemq.apache.org/components/classic/download/) and unzip it in a convenient place. Then navigate to the folder's `bin` directory in a terminal and run `./activemq console` (or just `activemq console` depending on your terminal) to make sure it's working. To be able to run activemq commands from anywhere, you can add this directory to your PATH environment variable if you want to. If you don't, you'll only be able to run activemq commands from one of the activemq `bin` directories, including those created with each broker you instantiate.

If the activemq console is working, you can create a new broker with `activemq create {path-to-broker}`. This will create the default broker in the designated directory. You can then start the broker with `activemq start xbean:file:{path-to-broker}/conf/activemq.xml`. This will start the broker from the configuration given in `activemq.xml`.

You can verify that the broker is running by accessing http://localhost:8161 in a web browser. After logging in with default credentials `username=admin password=admin` You should see a simple page showing "Welcome to the Apache ActiveMQ!".

## Code Organization

This project uses the JavaTM Architecture for XML Binding (JAXB) Reference Implementation, which automatically generates files in DeathDate-war/src/main/java/org/hl7/v3. Some of these files contain the following header:

```java
//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.4-2 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: {date} at {time} 
//
```

Note that the URL in the header is broken; see https://www.oracle.com/technical-resources/articles/javase/jaxb.html for more information on JAXB.
